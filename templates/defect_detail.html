{% extends "layout.html" %}
{% block title %}Defect: {{ defect.description | truncate(30) }}{% endblock %}

{% block content %}
    <!-- Header: Project Title and Back Button -->
    <div class="flex flex-row justify-between items-center mb-6 pb-4 border-b border-gray-300">
        {% if project and accessible_projects and accessible_projects|length > 0 %}
        <div class="relative" id="defect-page-project-dropdown-container">
            <button type="button" id="defect-page-project-dropdown-button" class="flex items-center text-2xl font-bold text-gray-800 hover:text-primary focus:outline-none">
                <span class="text-primary">{{ project.name }}</span> {# project is defect.project here #}
                <svg class="ml-2 h-5 w-5 text-gray-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
            </button>
            <div id="defect-page-project-dropdown-list" class="absolute left-0 mt-2 w-auto min-w-max max-w-md rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-50">
                <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="defect-page-project-dropdown-button">
                    <span class="block px-4 py-2 text-sm text-gray-500">Switch project:</span>
                    {% for acc_proj in accessible_projects %}
                        {% if acc_proj.id != project.id %}
                            <a href="{{ url_for('project_detail', project_id=acc_proj.id) }}" class="text-gray-700 block px-4 py-2 text-sm hover:bg-gray-100 hover:text-gray-900" role="menuitem">{{ acc_proj.name }}</a>
                        {% endif %}
                    {% endfor %}
                    {% if accessible_projects|length == 1 and project.id == accessible_projects[0].id %} {# Only current project accessible #}
                        <span class="block px-4 py-2 text-sm text-gray-400 italic">No other projects accessible.</span>
                    {% endif %}
                </div>
            </div>
        </div>
        {% else %}
            <h1 class="text-3xl font-bold text-gray-800">
                Project: <span class="text-primary">{{ project.name if project else "Unknown" }}</span>
            </h1>
        {% endif %}
        <div class="flex items-center">
            {% if current_user.role == 'admin' %}
            <form method="POST" action="{{ url_for('delete_defect_route', defect_id=defect.id) }}" class="inline">
                <input type="hidden" name="csrf_token" value="{{ csrf_token_value }}">
                <button type="submit"
                        class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md shadow-sm text-sm font-medium whitespace-nowrap mr-2"
                        onclick="return confirm('Are you sure you want to delete this defect?');">
                    Delete
                </button>
            </form>
            {% endif %}
            <a href="{{ url_for('project_detail', project_id=project.id, filter=defect.status) }}" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md shadow-sm text-sm font-medium whitespace-nowrap">Back</a>
        </div>
    </div>

    <!-- New Defect Information Card -->
    <div class="bg-white shadow-lg rounded-lg p-6 mb-6">
        <!-- Defect Description and Edit Form -->
        <div id="descriptionDisplayContainer" class="flex items-center mb-2">
            <h1 id="defectDescriptionText" class="text-2xl font-bold text-gray-800 break-words mr-3">{{ defect.description }}</h1>
            {% if current_user.id == defect.creator_id %}
            <button type="button" id="inlineEditDescriptionButton" class="text-sm text-blue-500 hover:text-blue-700 flex items-center p-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                <span>Edit</span>
            </button>
            {% endif %}
        </div>
        <div id="descriptionEditForm" class="hidden mt-2">
            <textarea id="descriptionTextarea" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-primary focus:border-primary" rows="4">{{ defect.description }}</textarea>
            <div class="mt-2">
                <button type="button" id="saveDescriptionButton" class="bg-primary hover:bg-primary-hover text-white px-3 py-1 rounded-md text-sm font-medium">Save Description</button>
                <button type="button" id="cancelDescriptionEditButton" class="ml-2 bg-gray-200 hover:bg-gray-300 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">Cancel</button>
            </div>
        </div>

        <!-- Defect Status, Creator, Dates -->
        <div class="mt-4 grid grid-cols-3 gap-x-4 gap-y-2">
            <div>
                <dt class="text-sm font-medium text-gray-500">Status</dt>
                <dd class="mt-1" id="statusContainer"> {# Re-using statusContainer ID for JS compatibility #}
                    {% if current_user.id == defect.creator_id %}
                        <select id="statusSelect" name="status" class="px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-primary focus:border-primary text-sm">
                            <option value="Open" {% if defect.status.lower() == 'open' %}selected{% endif %}>Open</option>
                            <option value="Closed" {% if defect.status.lower() == 'closed' %}selected{% endif %}>Closed</option>
                        </select>
                        <span id="statusUpdateMessage" class="ml-2 text-xs text-green-600"></span>
                    {% else %}
                        <span id="statusDisplaySpan" class="px-3 py-1 text-sm font-semibold rounded-full
                            {% if defect.status.lower() == 'open' %} bg-yellow-100 text-yellow-800
                            {% elif defect.status.lower() == 'closed' %} bg-green-100 text-green-800
                            {% else %} bg-gray-100 text-gray-800
                            {% endif %}">
                            {{ defect.status | capitalize }}
                        </span>
                    {% endif %}
                </dd>
            </div>
            <div>
                <dt class="text-sm font-medium text-gray-500">Created By</dt>
                <dd class="mt-1 text-sm text-gray-900">{{ defect.creator.username }}</dd>
            </div>
            <div>
                <dt class="text-sm font-medium text-gray-500">Creation Date</dt>
                <dd class="mt-1 text-sm text-gray-900">{{ defect.creation_date.strftime('%Y-%m-%d %H:%M:%S') }}</dd>
            </div>
            {% if defect.close_date %}
            <div>
                <dt class="text-sm font-medium text-gray-500">Close Date</dt>
                <dd class="mt-1 text-sm text-gray-900">{{ defect.close_date.strftime('%Y-%m-%d %H:%M:%S') }}</dd>
            </div>
            {% endif %}
        </div>
    </div>

    <div class="flex flex-col lg:flex-row gap-6">
        <!-- Left Column: Drawing, Attachments -->
        <div class="lg:w-2/3 flex flex-col gap-6">
            <!-- Attachments Card -->
            {% if attachments %}
                <div class="bg-white shadow-lg rounded-lg p-6 order-1 lg:order-none">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-lg font-normal text-gray-500">Attachments</h2>
                        <button type="button" id="addNewAttachmentButton" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Add defect photo</button>
                    </div>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                        {% for attachment in attachments %}
                            <div class="relative group">
                                <div role="button"
                                     {% if attachment.mime_type == 'application/pdf' %}
                                         onclick="openPdfPopup('{{ url_for('static', filename=attachment.file_path) }}');"
                                     {% else %}
                                         onclick="openImagePopup('{{ url_for('static', filename=attachment.file_path) }}', '{{ attachment.id }}', '/draw/');"
                                     {% endif %}
                                     class="block rounded-lg overflow-hidden border border-gray-200 hover:border-primary transition-all duration-300 cursor-pointer">

                                    {% if attachment.mime_type == 'application/pdf' %}
                                        {% if attachment.thumbnail_path %}
                                            <img src="{{ url_for('static', filename=attachment.thumbnail_path) }}" alt="PDF Thumbnail" class="w-full h-32 sm:h-40 object-contain group-hover:opacity-80 transition-opacity pointer-events-none">
                                        {% else %}
                                            {# Generic PDF icon/placeholder - using SVG for self-containment #}
                                            <div class="w-full h-32 sm:h-40 flex flex-col items-center justify-center bg-gray-100 text-gray-400 group-hover:opacity-80 transition-opacity p-2">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 3v4a1 1 0 001 1h4" /></svg>
                                                <span class="mt-1 text-xs text-center">PDF Document</span>
                                            </div>
                                        {% endif %}
                                    {% elif attachment.mime_type and attachment.mime_type.startswith('image/') %}
                                        <img src="{{ url_for('static', filename=attachment.thumbnail_path) }}" alt="Image Thumbnail" class="w-full h-32 sm:h-40 object-cover group-hover:opacity-80 transition-opacity pointer-events-none">
                                    {% else %}
                                         {# Fallback for unknown mime_types or old records without mime_type but with a thumbnail (likely images before mime_type was stored) #}
                                         {% if attachment.thumbnail_path %}
                                            <img src="{{ url_for('static', filename=attachment.thumbnail_path) }}" alt="Attachment" class="w-full h-32 sm:h-40 object-cover group-hover:opacity-80 transition-opacity pointer-events-none">
                                         {% else %}
                                            {# Generic file icon/placeholder if no thumbnail and unknown type #}
                                            <div class="w-full h-32 sm:h-40 flex flex-col items-center justify-center bg-gray-100 text-gray-400 group-hover:opacity-80 transition-opacity p-2">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" /></svg>
                                                <span class="mt-1 text-xs text-center">File</span>
                                            </div>
                                         {% endif %}
                                    {% endif %}
                                </div>
                                <button type="button" data-attachment-id="{{ attachment.id }}" class="absolute top-1 right-1 bg-red-500 hover:bg-red-700 text-white text-xs font-bold py-1 px-2 rounded opacity-0 group-hover:opacity-100 transition-opacity delete-attachment-button">Delete</button>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            {% endif %}

            <!-- Defect Location (Drawing) Card -->
{% if marker or current_user.id == defect.creator_id %}
            <div class="bg-white shadow-lg rounded-lg p-6 order-2 lg:order-none">
                <h2 class="text-lg font-normal text-gray-500 mb-4">Defect Location on Drawing</h2>
        
                {% if current_user.id == defect.creator_id %}
                    <!-- Drawing Selection for Editing -->
                    <div class="mb-4">
                        <label for="drawing_id_location_edit" class="block text-sm font-medium text-gray-700 mb-1">Select Drawing for Marker:</label>
                        <select name="drawing_id_location" id="drawing_id_location_edit" class="mt-1 block w-full px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-primary focus:border-primary sm:text-sm">
                            <option value="">None - Remove existing marker</option>
                            {% for drawing_item in drawings %} {# 'drawings' must be passed to template #}
                                <option value="{{ drawing_item.id }}" data-file-path="{{ drawing_item.file_path }}" {% if marker and marker.drawing_id == drawing_item.id %}selected{% endif %}>
                                    {{ drawing_item.name }}
                                </option>
                            {% endfor %}
                        </select>
                    </div>
        
                    <!-- PDF Viewer and Marker Placement Area -->
                    <div id="locationEditPdfContainer" class="border border-gray-300 w-full h-[400px] md:h-[500px] lg:h-[600px] relative bg-gray-200 flex items-center justify-center rounded-md overflow-hidden mb-4">
                        <div id="locationEditPdfStatus" class="text-gray-700 p-4 text-center">
                            <svg class="animate-spin h-8 w-8 text-primary mx-auto mb-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>Select a drawing to place a marker or view existing.</span>
                        </div>
                        <canvas id="locationEditPdfCanvas" class="absolute top-0 left-0 hidden"></canvas>
                        <canvas id="locationEditMarkerCanvas" class="absolute top-0 left-0 cursor-crosshair"></canvas>
                    </div>
                    <input type="hidden" name="marker_x_location" id="marker_x_location_edit" value="{{ marker.x if marker and marker.x is not none else '' }}">
                    <input type="hidden" name="marker_y_location" id="marker_y_location_edit" value="{{ marker.y if marker and marker.y is not none else '' }}">
                    <input type="hidden" name="page_num_location" id="page_num_location_edit" value="{{ marker.page_num if marker and marker.page_num is not none else '1' }}">
                    
                    <div class="flex justify-end space-x-3">
                         <button type="button" id="removeLocationButton" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md text-sm font-medium {% if not marker %}hidden{% endif %}">Remove Location</button>
                         <button type="button" id="saveLocationButton" class="bg-primary hover:bg-primary-hover text-white px-4 py-2 rounded-md text-sm font-medium">Save Location Changes</button>
                    </div>
                    <span id="locationUpdateMessage" class="block mt-2 text-xs text-green-600 text-right"></span>
        
                {% else %}
                    <!-- Static Display for non-authorized users -->
                    {% if marker %}
                        <div id="staticPdfContainer" class="border border-gray-300 w-full h-[400px] md:h-[500px] lg:h-[600px] relative bg-gray-200 flex items-center justify-center rounded-md overflow-hidden">
                            <div id="staticPdfStatus" class="text-gray-700 p-4 text-center">
                                <svg class="animate-spin h-8 w-8 text-primary mx-auto mb-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                Loading PDF...
                            </div>
                            <canvas id="staticPdfCanvas" class="absolute top-0 left-0"></canvas>
                            <canvas id="staticMarkerCanvas" class="absolute top-0 left-0 pointer-events-none"></canvas>
                        </div>
                         <p class="text-sm text-gray-700 mt-2">Drawing: {{ marker.drawing_name if marker.drawing_name else 'N/A' }} | Page: {{ marker.page_num if marker.page_num else '1' }} | X: {{ "%.3f"|format(marker.x) if marker.x is not none else 'N/A' }} | Y: {{ "%.3f"|format(marker.y) if marker.y is not none else 'N/A' }}</p>
                    {% else %}
                        <p class="text-sm text-gray-500">No drawing location specified for this defect.</p>
                    {% endif %}
                {% endif %}
            </div>
{% endif %}
        </div>

        <!-- Right Column: Actions, Comments -->
        <div class="lg:w-1/3 space-y-6">
            <!-- Comments List Card -->
            <div class="bg-white shadow-lg rounded-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Comments</h2>
                {% if comments %}
                    <div class="space-y-4">
                        {% for comment in comments %}
                            <div class="p-4 bg-gray-50 rounded-lg border border-gray-200" id="comment-{{ comment.id }}">
                                <div class="flex justify-between items-center mb-1">
                                    <p class="text-sm font-semibold text-primary">{{ comment.user.username }}</p>
                                    <div class="flex items-center space-x-2">
                                        <p class="text-xs text-gray-500">
                                            {{ comment.created_at.strftime('%Y-%m-%d %H:%M') }}
                                            {% if comment.edited %}<span class="text-gray-400 italic" id="comment-edited-at-{{ comment.id }}">(edited {{ comment.updated_at.strftime('%Y-%m-%d %H:%M') }})</span>{% endif %}
                                        </p>
                                        {% if current_user.id == comment.user_id or current_user.role == 'admin' %}
                                            <button type="button" class="edit-comment-button text-xs text-blue-500 hover:text-blue-700 p-1" data-comment-id="{{ comment.id }}" title="Edit comment">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                                            </button>
                                            <button type="button" class="delete-comment-button text-xs text-red-500 hover:text-red-700 p-1" data-comment-id="{{ comment.id }}" title="Delete comment">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                            </button>
                                        {% endif %}
                                    </div>
                                </div>
                                <p class="text-sm text-gray-700 break-words comment-content-display">{{ comment.content }}</p>
                                <!-- Edit form (initially hidden) -->
                                <div class="comment-edit-form hidden mt-2">
                                    <textarea class="comment-edit-textarea w-full p-2 border border-gray-300 rounded-md text-sm" rows="3">{{ comment.content }}</textarea>
                                    <div class="mt-1">
                                        <button type="button" class="save-comment-button bg-primary hover:bg-primary-hover text-white px-2 py-1 rounded-md text-xs">Save</button>
                                        <button type="button" class="cancel-comment-edit-button ml-1 bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded-md text-xs">Cancel</button>
                                    </div>
                                </div>
                                {% set comment_attachments = comment.attachments %}
                                {% if comment_attachments %}
                                    <div class="mt-3 grid grid-cols-2 sm:grid-cols-3 gap-2">
                                        {% for attachment in comment_attachments %}
                                            <div role="button" onclick="openImagePopup('{{ url_for('static', filename=attachment.file_path) }}', '{{ attachment.id }}', '/draw/');" class="group block rounded overflow-hidden border border-gray-100 hover:border-primary transition-all duration-300 cursor-pointer">
                                                <img src="{{ url_for('static', filename=attachment.thumbnail_path) }}" alt="Comment Attachment" class="w-full h-20 sm:h-24 object-cover group-hover:opacity-80 transition-opacity pointer-events-none">
                                            </div>
                                        {% endfor %}
                                    </div>
                                {% endif %}
                            </div>
                        {% endfor %}
                    </div>
                {% else %}
                    <p class="text-sm text-gray-500">No comments yet. Be the first to comment!</p>
                {% endif %}
            </div>

            <!-- Add Comment Form Card -->
            {% if user_role in ['admin', 'expert', 'worker', 'contractor', 'Technical supervisor'] %}
                <div class="bg-white shadow-lg rounded-lg p-6">
                    <h2 class="text-2xl font-semibold text-gray-700 mb-4">Add Comment</h2>
                    <form method="POST" enctype="multipart/form-data" class="space-y-4">
                        <input type="hidden" name="csrf_token" value="{{ csrf_token_value }}">
                        <input type="hidden" name="action" value="add_comment">
                        <div>
                            <label for="comment_content" class="block text-sm font-medium text-gray-700">Your Comment</label>
                            <textarea name="comment_content" id="comment_content" rows="4" class="mt-1 p-2 w-full border border-gray-300 rounded-md shadow-sm focus:ring-primary focus:border-primary" required></textarea>
                        </div>
                        <div>
                            <label for="comment_photos" class="block text-sm font-medium text-gray-700">Attach Photos (Optional)</label>
                            <input type="file" name="comment_photos" id="comment_photos" multiple accept="image/*" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-white hover:file:bg-primary-hover file:cursor-pointer">
                        </div>
                        <button type="submit" class="w-full bg-primary hover:bg-primary-hover text-white px-4 py-2 rounded-md shadow-sm text-sm font-medium">Submit Comment</button>
                    </form>
                </div>
            {% endif %}
        </div>
    </div>

    <div id="pdfViewerModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-3xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center pb-3 border-b">
                <h3 class="text-xl font-semibold">PDF Viewer</h3>
                <button id="closePdfModalButton" class="text-black text-2xl">&times;</button>
            </div>
            <div class="flex items-center justify-center space-x-2 py-2 border-b">
                <button id="pdfPrevPage" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">Prev</button>
                <span id="pdfPageNum" class="text-sm"></span> / <span id="pdfPageCount" class="text-sm"></span>
                <button id="pdfNextPage" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">Next</button>
                <button id="pdfZoomIn" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">Zoom In</button>
                <button id="pdfZoomOut" class="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">Zoom Out</button>
            </div>
            <div id="pdfRenderArea" class="flex-grow overflow-auto py-2">
                <canvas id="pdfCanvas" class="mx-auto"></canvas>
            </div>
        </div>
    </div>

    {% if marker %}
    <script src="{{ url_for('static', filename='js/pdf.min.js') }}"></script>
    <script>
        // Script for STATIC PDF/Marker Display (for non-authorized users or when not editing)
        // This script is active if a marker exists and the user is not authorized to edit,
        // or if there's a general need to display a static marker.
        // It targets: staticPdfContainer, staticPdfStatus, staticPdfCanvas, staticMarkerCanvas
        const staticPdfContainer = document.getElementById('staticPdfContainer');
        if (staticPdfContainer) {
            console.log("DEFECT_DETAIL_STATIC_PDF: Script execution started for static PDF preview.");
            try {
                const pdfStatusEl = document.getElementById('staticPdfStatus');
                const pdfCanvas = document.getElementById('staticPdfCanvas');
                const markerCanvas = document.getElementById('staticMarkerCanvas');
                
                if (!pdfStatusEl || !pdfCanvas || !markerCanvas) {
                    console.error("DEFECT_DETAIL_STATIC_PDF: Critical elements missing (pdfStatusEl, pdfCanvas, or markerCanvas).");
                    throw new Error("Essential PDF display elements are missing from the page.");
                }
                const ctx = markerCanvas.getContext('2d');

                let pdfDoc = null;
                let pageNum = 1; // Default to first page
                let currentScale = 1; // Store current scale

                // Marker data from Flask template - this is already available in this scope
                // const markerData = {{ marker|tojson|safe }}; // Already present, just for reference

                function updateStatus(message, isLoading = false) {
                    console.log(`DEFECT_DETAIL_STATIC_PDF: updateStatus - Message: "${message}", isLoading: ${isLoading}`);
                    if (pdfStatusEl) {
                        if (isLoading) {
                            pdfStatusEl.innerHTML = `
                                <svg class="animate-spin h-8 w-8 text-primary mx-auto mb-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                ${message}`;
                            pdfStatusEl.style.color = ''; // Reset color for loading messages
                        } else {
                            pdfStatusEl.textContent = message;
                        }
                        pdfStatusEl.style.display = message ? 'flex' : 'none';
                        if (pdfCanvas) pdfCanvas.style.display = message && !message.toLowerCase().includes("error drawing") ? 'none' : 'block'; // Hide canvas if loading, show if error or success

                        if (!isLoading && message && message.toLowerCase().includes("error")) {
                             pdfStatusEl.style.display = 'flex';
                             pdfStatusEl.style.color = 'red';
                        }
                    } else {
                        console.warn("DEFECT_DETAIL_STATIC_PDF: updateStatus - pdfStatusEl is null.");
                    }
                }

                function renderPage(page) {
                    console.log("DEFECT_DETAIL_STATIC_PDF: renderPage - Starting for page number:", page.pageNumber);
                    try {
                        const viewport = page.getViewport({ scale: currentScale });
                        pdfCanvas.width = viewport.width;
                        pdfCanvas.height = viewport.height;
                        markerCanvas.width = viewport.width;
                        markerCanvas.height = viewport.height;

                        const renderContext = {
                            canvasContext: pdfCanvas.getContext('2d'),
                            viewport: viewport
                        };
                        console.log("DEFECT_DETAIL_STATIC_PDF: renderPage - Calling page.render().");
                        page.render(renderContext).promise.then(() => {
                            console.log("DEFECT_DETAIL_STATIC_PDF: renderPage - page.render() successful.");
                            updateStatus(''); // Clear loading message
                            pdfCanvas.style.display = 'block';

                            const markerData = {{ marker | tojson }}; // Re-fetch or use global if sure it's unchanged
                            console.log("DEFECT_DETAIL_STATIC_PDF: renderPage - Marker data for drawing:", markerData);

                            if (markerData && typeof markerData.x === 'number' && typeof markerData.y === 'number' && markerData.page_num === page.pageNumber) {
                                ctx.clearRect(0, 0, markerCanvas.width, markerCanvas.height);
                                const markerRadius = Math.max(5, Math.min(viewport.width, viewport.height) * 0.015);
                                const markerX = markerData.x * viewport.width;
                                const markerY = markerData.y * viewport.height;
                                console.log("DEFECT_DETAIL_STATIC_PDF: renderPage - Drawing marker at (scaled coords): X=", markerX, "Y=", markerY);
                                ctx.beginPath();
                                ctx.arc(markerX, markerY, markerRadius, 0, 2 * Math.PI, false);
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                                ctx.fill();
                                ctx.lineWidth = Math.max(1, markerRadius * 0.2);
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                ctx.stroke();
                            } else {
                                console.warn('DEFECT_DETAIL_STATIC_PDF: renderPage - Invalid or missing marker coordinates, or marker not for this page.', markerData);
                            }
                        }).catch(renderError => {
                            console.error('DEFECT_DETAIL_STATIC_PDF: renderPage - Error during page.render() promise:', renderError);
                            updateStatus('Error rendering PDF page content: ' + (renderError.message || String(renderError)));
                        });
                    } catch (e) {
                        console.error('DEFECT_DETAIL_STATIC_PDF: renderPage - Synchronous error:', e);
                        updateStatus('Critical error displaying PDF page: ' + (e.message || String(e)));
                    }
                }

                function calculateScaleAndRender(pdfPage) {
                    console.log("DEFECT_DETAIL_STATIC_PDF: calculateScaleAndRender - Starting for page", pdfPage ? pdfPage.pageNumber : 'N/A');
                    if (!staticPdfContainer) {
                        console.error("DEFECT_DETAIL_STATIC_PDF: calculateScaleAndRender - staticPdfContainer is null.");
                        updateStatus("Error: PDF display container missing.");
                        return;
                    }
                     if (!pdfPage) {
                        console.error("DEFECT_DETAIL_STATIC_PDF: calculateScaleAndRender - pdfPage is null.");
                        updateStatus("Error: PDF page data missing for scaling.");
                        return;
                    }
                    // Calculate scale to fit width, then set height dynamically
                    const pageWidth = pdfPage.getViewport({ scale: 1 }).width;
                    currentScale = staticPdfContainer.clientWidth / pageWidth; // Changed pdfContainer to staticPdfContainer

                    const scaledViewport = pdfPage.getViewport({ scale: currentScale });
                    staticPdfContainer.style.height = `${scaledViewport.height}px`; // Changed pdfContainer to staticPdfContainer

                    console.log('DEFECT_DETAIL_STATIC_PDF: calculateScaleAndRender - Calculated scale:', currentScale, 'Container clientWidth:', staticPdfContainer.clientWidth);
                    renderPage(pdfPage);
                }

                function loadPDF() {
                    console.log("DEFECT_DETAIL_STATIC_PDF: loadPDF - Starting.");
                    const markerData = {{ marker | tojson }}; // Use markerData for clarity
                    console.log("DEFECT_DETAIL_STATIC_PDF: loadPDF - Marker data from template:", markerData);

                    if (!markerData || typeof markerData !== 'object') {
                        console.warn('DEFECT_DETAIL_STATIC_PDF: loadPDF - markerData is null, undefined, or not an object.', markerData);
                        updateStatus('Drawing data is unavailable.');
                        return;
                    }
                    if (!markerData.file_path || typeof markerData.file_path !== 'string') {
                        console.warn('DEFECT_DETAIL_STATIC_PDF: loadPDF - No valid file_path in markerData:', markerData.file_path);
                        updateStatus('No drawing file specified for this defect.');
                        return;
                    }

                    let rawFilePath = markerData.file_path;
                    if (rawFilePath.startsWith('/static/')) {
                        rawFilePath = rawFilePath.substring('/static/'.length);
                    }
                    // This logic for drawings/ prefix might need adjustment based on actual file_path structure
                    if (!rawFilePath.startsWith('drawings/')) {
                        const parts = rawFilePath.split('/');
                        const fileName = parts.pop();
                        if (parts.length > 0 && parts[0] === 'drawings') {
                           // Path was like 'drawings/subfolder/file.pdf', already handled by outer if or doesn't need 'drawings/' prefix
                        } else { // e.g. 'file.pdf' or 'some_other_folder/file.pdf'
                            rawFilePath = 'drawings/' + fileName;
                        }
                    }
                    const pdfUrl = `/static/${rawFilePath.startsWith('/') ? rawFilePath.substring(1) : rawFilePath}`;
                    console.log("DEFECT_DETAIL_STATIC_PDF: loadPDF - Attempting to load PDF from URL:", pdfUrl);
                    updateStatus('Loading PDF...', true);

                    pdfjsLib.getDocument(pdfUrl).promise.then(loadedPdf => {
                        pdfDoc = loadedPdf;
                        console.log('DEFECT_DETAIL_STATIC_PDF: loadPDF - PDF document loaded. Total pages:', pdfDoc.numPages);
                        pageNum = markerData.page_num || 1;
                        if (pageNum > pdfDoc.numPages || pageNum < 1) {
                            console.warn(`DEFECT_DETAIL_STATIC_PDF: Requested page ${pageNum} is out of range (Total: ${pdfDoc.numPages}). Defaulting to page 1.`);
                            pageNum = 1;
                        }
                        console.log("DEFECT_DETAIL_STATIC_PDF: loadPDF - Attempting to get page:", pageNum);
                        return pdfDoc.getPage(pageNum);
                    }).then(page => {
                        console.log("DEFECT_DETAIL_STATIC_PDF: loadPDF - PDF page", pageNum, "loaded successfully.");
                        calculateScaleAndRender(page);
                        let resizeTimeout;
                        window.addEventListener('resize', () => {
                            clearTimeout(resizeTimeout);
                            resizeTimeout = setTimeout(() => {
                                if (pdfDoc && pdfDoc.getPage) { // Check if pdfDoc is still valid and has getPage
                                    pdfDoc.getPage(pageNum).then(calculateScaleAndRender).catch(pageError => {
                                        console.error("DEFECT_DETAIL_STATIC_PDF: Error getting page on resize:", pageError);
                                        updateStatus("Error processing PDF on resize: " + (pageError.message || String(pageError)));
                                    });
                                } else {
                                    console.warn("DEFECT_DETAIL_STATIC_PDF: pdfDoc not available for resize handling.");
                                }
                            }, 250);
                        });
                    }).catch(error => {
                        console.error('DEFECT_DETAIL_STATIC_PDF: loadPDF - Error during getDocument or getPage promise chain:', error);
                        let errorMessage = 'Unknown error';
                        if (error && error.message) errorMessage = error.message;
                        else if (error && typeof error === 'string') errorMessage = error;
                        else if (error && error.name === 'MissingPDFException') errorMessage = 'PDF file not found or could not be loaded.';
                        else if (error && error.name === 'InvalidPDFException') errorMessage = 'Invalid or corrupted PDF file.';
                        else if (error && error.status === 404) errorMessage = 'PDF file not found (404). Check path: ' + pdfUrl;
                        updateStatus('Error loading PDF document: ' + errorMessage);
                    });
                }

                loadPDF();

            } catch (outerError) {
                console.error("DEFECT_DETAIL_STATIC_PDF: General synchronous error in static PDF script setup:", outerError);
                // Use updateStatus if available and elements are there, otherwise alert.
                if (typeof updateStatus === 'function' && document.getElementById('staticPdfStatus')) {
                     updateStatus('Fatal error initializing PDF preview: ' + (outerError.message || String(outerError)));
                } else {
                    alert('A critical error occurred setting up the PDF preview. Please refresh the page or contact support if the issue persists.');
                }
            }
        } else {
             console.warn("DEFECT_DETAIL_STATIC_PDF: staticPdfContainer element was not found in the DOM... PDF preview cannot be initialized.");
        }
    </script>
    {% endif %}

{% if current_user.id == defect.creator_id or current_user.role in ['admin', 'expert', 'Technical supervisor'] %}
    {% if not marker %}
    <script src="{{ url_for('static', filename='js/pdf.min.js') }}"></script>
    {% endif %}
    <script>
        // Ensure pdfjsLib is defined before trying to set GlobalWorkerOptions
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = "{{ url_for('static', filename='js/pdf.worker.min.js') }}";
        } else {
            console.error("JULES: pdfjsLib not defined for editor context when trying to set workerSrc. This might happen if a user who can edit loads a defect page without an existing marker, and pdf.min.js was not loaded by the 'not marker' condition, which would be unexpected.");
        }
    </script>
{% endif %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    // The check for pdfjsLib below is important.
    // It ensures that if pdfjsLib is still not defined (e.g. due to an unexpected issue with the above logic),
    // the script doesn't crash when trying to use it.
    if (typeof pdfjsLib === 'undefined') {
        console.error("pdfjsLib is not defined. PDF functionality will not work for editing markers.");
        return;
    }
    // Assuming workerSrc is set globally by the other script. If not, uncomment:
    // pdfjsLib.GlobalWorkerOptions.workerSrc = "{{ url_for('static', filename='js/pdf.worker.min.js') }}";

    // Defect Edit Toggle & Attachment Management Script
    // const editDefectButton = document.getElementById('editDefectButton'); // Old button, removed
    // const editDefectFormContainer = document.getElementById('editDefectFormContainer'); // Old container, removed
    const addNewAttachmentButton = document.getElementById('addNewAttachmentButton');
    const deleteAttachmentButtons = document.querySelectorAll('.delete-attachment-button');
    const csrfToken = '{{ csrf_token_value }}'; // Assuming csrf_token_value is passed to the template
    const defectId = '{{ defect.id }}';

    // 1. Edit Defect Toggle Functionality (Old - to be removed or commented out)
    // if (editDefectButton && editDefectFormContainer) { // editDefectButton is null now
    //     editDefectButton.addEventListener('click', function() {
    //         const isHidden = editDefectFormContainer.classList.toggle('hidden');
    //         if (isHidden) {
    //             editDefectButton.textContent = 'Edit Defect';
    //         } else {
    //             editDefectButton.textContent = 'Cancel';
    //         }
    //     });
    // }

    // Inline Description Edit Toggle
    const inlineEditDescriptionButton = document.getElementById('inlineEditDescriptionButton');
    const descriptionDisplayContainer = document.getElementById('descriptionDisplayContainer');
    const defectDescriptionText = document.getElementById('defectDescriptionText'); // The h1 tag
    const descriptionEditForm = document.getElementById('descriptionEditForm');
    const descriptionTextarea = document.getElementById('descriptionTextarea');
    const saveDescriptionButton = document.getElementById('saveDescriptionButton');
    const cancelDescriptionEditButton = document.getElementById('cancelDescriptionEditButton');

    if (inlineEditDescriptionButton && descriptionDisplayContainer && descriptionEditForm && descriptionTextarea && defectDescriptionText) {
        inlineEditDescriptionButton.addEventListener('click', function() {
            descriptionDisplayContainer.classList.add('hidden');
            descriptionEditForm.classList.remove('hidden');
            descriptionTextarea.value = defectDescriptionText.textContent.trim();
            descriptionTextarea.focus();
        });

        if (cancelDescriptionEditButton) {
            cancelDescriptionEditButton.addEventListener('click', function() {
                descriptionEditForm.classList.add('hidden');
                descriptionDisplayContainer.classList.remove('hidden');
            });
        }
        
        if (saveDescriptionButton) {
            saveDescriptionButton.addEventListener('click', function() {
                const newDescription = descriptionTextarea.value.trim();
                // defectId and csrfToken are already defined at the top of this script block

                if (!newDescription) {
                    alert("Description cannot be empty.");
                    return;
                }

                fetch(`/defect/${defectId}/update_description`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken 
                    },
                    body: JSON.stringify({ description: newDescription })
                })
                .then(response => {
                    if (!response.ok) { // Check for non-2xx responses
                        return response.json().then(errData => {
                            throw new Error(errData.error || `HTTP error! status: ${response.status}`);
                        });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        if(defectDescriptionText) defectDescriptionText.textContent = data.new_description;
                        descriptionTextarea.value = data.new_description;
                        
                        descriptionEditForm.classList.add('hidden');
                        if(descriptionDisplayContainer) descriptionDisplayContainer.classList.remove('hidden');
                        
                        // Optional: Simple success feedback
                        // alert(data.message); 
                    } else {
                        alert('Error: ' + (data.error || 'Unknown error updating description.'));
                    }
                })
                .catch(error => {
                    console.error('Error saving description:', error);
                    alert('An error occurred while saving the description: ' + error.message);
                });
            });
        }
    }

    // Status Auto-Save Functionality
    const statusSelect = document.getElementById('statusSelect');
    const statusUpdateMessage = document.getElementById('statusUpdateMessage');
    // const statusDisplaySpan = document.getElementById('statusDisplaySpan'); // For updating static view if needed

    if (statusSelect) {
        statusSelect.addEventListener('change', function() {
            const newStatus = this.value;
            // defectId and csrfToken are already defined at the top of this script block

            if (statusUpdateMessage) statusUpdateMessage.textContent = 'Saving...';

            fetch(`/defect/${defectId}/update_status`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({ status: newStatus })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => {
                        throw new Error(errData.error || `HTTP error! Status: ${response.status}`);
                    }).catch(() => {
                        throw new Error(`HTTP error! Status: ${response.statusText || response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    if (statusUpdateMessage) {
                        statusUpdateMessage.textContent = 'Saved!';
                        setTimeout(() => { if(statusUpdateMessage) statusUpdateMessage.textContent = ''; }, 2000);
                    }
                    // The select dropdown itself reflects the new status.
                    // If the static span #statusDisplaySpan needs to be updated (e.g. for other user roles not seeing the select),
                    // or if the mobile view's badge needs an update, that would require additional logic here.
                } else {
                    alert('Error: ' + (data.error || 'Unknown error updating status.'));
                    if (statusUpdateMessage) statusUpdateMessage.textContent = 'Error!';
                    // Optionally, revert statusSelect.value to its original pre-change value here.
                }
            })
            .catch(error => {
                console.error('Error updating status:', error);
                alert('An error occurred: ' + error.message);
                if (statusUpdateMessage) statusUpdateMessage.textContent = 'Error!';
            });
        });
    }

    // 2. "Add New Image" Functionality
    if (addNewAttachmentButton) {
        let newAttachmentInput = document.getElementById('newAttachmentInput');
        if (!newAttachmentInput) {
            newAttachmentInput = document.createElement('input');
            newAttachmentInput.type = 'file';
            newAttachmentInput.id = 'newAttachmentInput';
            newAttachmentInput.accept = 'image/*,application/pdf';
            newAttachmentInput.classList.add('hidden');
            document.body.appendChild(newAttachmentInput); // Add it to the body
        }

        addNewAttachmentButton.addEventListener('click', function() {
            newAttachmentInput.click();
        });

        newAttachmentInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const formData = new FormData();
                formData.append('attachment_file', file);
                formData.append('defect_id', defectId);
                formData.append('csrf_token', csrfToken);

                fetch(`/defect/${defectId}/attachment/add`, {
                    method: 'POST',
                    body: formData,
                    // Flask-WTF typically checks CSRF token from FormData for AJAX if not using X-CSRFToken header
                    // headers: { 'X-CSRFToken': csrfToken } // Example if using header-based CSRF
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // alert('Attachment added successfully!'); // Optional alert
                        location.reload(); // Reload to see the new attachment
                    } else {
                        alert('Error adding attachment: ' + (data.message || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('Error uploading attachment:', error);
                    alert('Error uploading attachment. See console for details.');
                });
                
                // Reset file input for next selection
                event.target.value = null;
            }
        });
    }

    // Comment Edit/Delete Functionality
    document.querySelectorAll('.edit-comment-button').forEach(button => {
        button.addEventListener('click', function() {
            const commentId = this.dataset.commentId;
            const commentBlock = document.getElementById(`comment-${commentId}`);
            if (!commentBlock) return;
            const displayP = commentBlock.querySelector('.comment-content-display');
            const editForm = commentBlock.querySelector('.comment-edit-form');
            const textarea = commentBlock.querySelector('.comment-edit-textarea');
            
            if(displayP && editForm && textarea) {
                displayP.classList.add('hidden');
                editForm.classList.remove('hidden');
                textarea.value = displayP.textContent.trim(); // Ensure fresh content
                textarea.focus();
            }
        });
    });

    document.querySelectorAll('.cancel-comment-edit-button').forEach(button => {
        button.addEventListener('click', function() {
            const commentBlock = this.closest('.p-4'); 
            if (!commentBlock) return;
            const displayP = commentBlock.querySelector('.comment-content-display');
            const editForm = commentBlock.querySelector('.comment-edit-form');
            
            if(displayP && editForm) {
                editForm.classList.add('hidden');
                displayP.classList.remove('hidden');
            }
        });
    });

    document.querySelectorAll('.save-comment-button').forEach(button => {
        button.addEventListener('click', function() {
            const commentBlock = this.closest('.p-4');
            if (!commentBlock) return;
            const commentId = commentBlock.id.split('-')[1];
            const textarea = commentBlock.querySelector('.comment-edit-textarea');
            const newContent = textarea.value.trim();
            // csrfToken is defined globally in this script block

            if (!newContent) { alert("Comment cannot be empty."); return; }

            fetch(`/comment/${commentId}/edit`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({ content: newContent })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => { throw new Error(errData.error || `HTTP error! status: ${response.status}`); });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    const displayP = commentBlock.querySelector('.comment-content-display');
                    if(displayP) displayP.textContent = data.new_content;
                    
                    const editedAtSpanId = `comment-edited-at-${commentId}`;
                    let editedAtSpan = document.getElementById(editedAtSpanId);
                    const timeP = commentBlock.querySelector('.text-xs.text-gray-500');

                    if (timeP && data.edited_at) {
                        if (!editedAtSpan) { // Create if doesn't exist
                            const originalTime = timeP.textContent.split('(edited')[0].trim();
                            timeP.innerHTML = `${originalTime} <span class="text-gray-400 italic" id="${editedAtSpanId}"></span>`;
                            editedAtSpan = document.getElementById(editedAtSpanId);
                        }
                        if(editedAtSpan) editedAtSpan.textContent = `(edited ${data.edited_at})`;
                    }

                    const editForm = commentBlock.querySelector('.comment-edit-form');
                    if(editForm) editForm.classList.add('hidden');
                    if(displayP) displayP.classList.remove('hidden');
                } else { 
                    alert('Error: ' + (data.error || "Unknown error updating comment.")); 
                }
            })
            .catch(error => {
                console.error('Error saving comment:', error);
                alert('An error occurred while saving the comment: ' + error.message);
            });
        });
    });
    
    document.querySelectorAll('.delete-comment-button').forEach(button => {
        button.addEventListener('click', function() {
            const commentId = this.dataset.commentId;
            // csrfToken is defined globally

            if (confirm('Are you sure you want to delete this comment and its attachments?')) {
                fetch(`/comment/${commentId}/delete`, {
                    method: 'POST',
                    headers: {
                        // CSRF token can be sent in header or as part of FormData/JSON body
                        // For JSON, it's often in header. For FormData, it can be a field.
                        'X-CSRFToken': csrfToken 
                        // If sending as JSON body and backend expects it there:
                        // 'Content-Type': 'application/json' 
                    },
                    // body: JSON.stringify({ csrf_token: csrfToken }) // If sending as JSON body
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(errData => { throw new Error(errData.error || `HTTP error! status: ${response.status}`); });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        const commentElement = document.getElementById(`comment-${commentId}`);
                        if(commentElement) commentElement.remove();
                    } else { 
                        alert('Error: ' + (data.error || "Unknown error deleting comment.")); 
                    }
                })
                .catch(error => {
                    console.error('Error deleting comment:', error);
                    alert('An error occurred while deleting the comment: ' + error.message);
                });
            }
        });
    });

    // 3. "Delete Image" Functionality
    deleteAttachmentButtons.forEach(button => {
        button.addEventListener('click', function(event) {
            const attachmentId = event.target.dataset.attachmentId;
            if (confirm('Are you sure you want to delete this attachment?')) {
                const formData = new FormData();
                formData.append('attachment_id', attachmentId);
                formData.append('defect_id', defectId); // Include defect_id for endpoint consistency
                formData.append('csrf_token', csrfToken);

                fetch(`/defect/${defectId}/attachment/delete`, {
                    method: 'POST',
                    body: formData,
                    // headers: { 'X-CSRFToken': csrfToken }  // Example if using header-based CSRF
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // alert('Attachment deleted successfully!'); // Optional alert
                        event.target.closest('.relative.group').remove(); // Remove the attachment's div
                    } else {
                        alert('Error deleting attachment: ' + (data.message || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('Error deleting attachment:', error);
                    alert('Error deleting attachment. See console for details.');
                });
            }
        });
    });

    // Marker Editing for Defect Location (formerly drawingSelectEdit, etc.)
    const drawingSelectLocationEdit = document.getElementById('drawing_id_location_edit');
    const locationEditPdfContainer = document.getElementById('locationEditPdfContainer');
    const locationEditPdfStatusEl = document.getElementById('locationEditPdfStatus');
    const locationEditPdfCanvas = document.getElementById('locationEditPdfCanvas');
    const locationEditMarkerCanvas = document.getElementById('locationEditMarkerCanvas');
    const markerXLocationInput = document.getElementById('marker_x_location_edit');
    const markerYLocationInput = document.getElementById('marker_y_location_edit');
    const pageNumLocationInput = document.getElementById('page_num_location_edit');
    const removeLocationButton = document.getElementById('removeLocationButton');
    const saveLocationButton = document.getElementById('saveLocationButton');
    const locationUpdateMessage = document.getElementById('locationUpdateMessage');


    // Check if the primary element for this script section (drawingSelectLocationEdit) exists
    if (drawingSelectLocationEdit && locationEditPdfContainer && locationEditMarkerCanvas) {
        console.log("Editable marker display script executing.");
        console.log("Editable display - initial markerX from input:", document.getElementById('marker_x_location_edit').value);
        console.log("Editable display - initial markerY from input:", document.getElementById('marker_y_location_edit').value);
        console.log("Editable display - initial pageNum from input:", document.getElementById('page_num_location_edit').value);
        console.log("Editable display - initial drawing_id selected:", document.getElementById('drawing_id_location_edit').value);

        const ctxLocationEdit = locationEditMarkerCanvas.getContext('2d');
        let pdfDocLocationEdit = null;
        let currentPageNumLocationEdit = 1; 
        let currentScaleLocationEdit = 1;
        let currentMarkerDataLocation = null; // Holds {x, y, pageNum} from hidden inputs or clicks

        // Initialize currentMarkerDataLocation from hidden inputs if values exist
        if (markerXLocationInput.value && markerYLocationInput.value && pageNumLocationInput.value) {
            currentMarkerDataLocation = {
                x: parseFloat(markerXLocationInput.value),
                y: parseFloat(markerYLocationInput.value),
                pageNum: parseInt(pageNumLocationInput.value)
            };
        }
        
        function updateLocationEditStatus(message, isLoading = false) {
            if (!locationEditPdfStatusEl) return;
            const spinnerSVG = `
                <svg class="animate-spin h-8 w-8 text-primary mx-auto mb-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>`;
            if (isLoading) {
                locationEditPdfStatusEl.innerHTML = spinnerSVG + `<span>${message}</span>`;
                locationEditPdfStatusEl.classList.remove('hidden');
                if(locationEditPdfCanvas) locationEditPdfCanvas.classList.add('hidden');
            } else if (message) {
                locationEditPdfStatusEl.innerHTML = `<span>${message}</span>`; // No spinner if just a message
                locationEditPdfStatusEl.classList.remove('hidden');
                 if(locationEditPdfCanvas) locationEditPdfCanvas.classList.add('hidden');
            } else { // No message, no loading -> hide status, show canvas
                locationEditPdfStatusEl.classList.add('hidden');
                if(locationEditPdfCanvas) locationEditPdfCanvas.classList.remove('hidden');
            }
        }

        function drawMarkerLocationEdit() {
            if (!pdfDocLocationEdit || !ctxLocationEdit || !locationEditMarkerCanvas) return;
            ctxLocationEdit.clearRect(0, 0, locationEditMarkerCanvas.width, locationEditMarkerCanvas.height);
            if (currentMarkerDataLocation && currentMarkerDataLocation.pageNum === currentPageNumLocationEdit) {
                 pdfDocLocationEdit.getPage(currentPageNumLocationEdit).then(page => {
                    const viewport = page.getViewport({ scale: currentScaleLocationEdit });
                    const markerRadius = Math.max(5, Math.min(viewport.width, viewport.height) * 0.015);
                    const markerX = currentMarkerDataLocation.x * viewport.width;
                    const markerY = currentMarkerDataLocation.y * viewport.height;
                    ctxLocationEdit.beginPath();
                    ctxLocationEdit.arc(markerX, markerY, markerRadius, 0, 2 * Math.PI, false);
                    ctxLocationEdit.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctxLocationEdit.fill();
                    ctxLocationEdit.lineWidth = Math.max(1, markerRadius * 0.2);
                    ctxLocationEdit.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctxLocationEdit.stroke();
                });
            }
        }

        function renderPageLocationEdit(pageNumber) {
            if (!pdfDocLocationEdit || !locationEditPdfContainer || !locationEditPdfCanvas) {
                updateLocationEditStatus('PDF document or canvas not ready.', false);
                return;
            }
            updateLocationEditStatus('Loading page ' + pageNumber + '...', true);
            pdfDocLocationEdit.getPage(pageNumber).then(page => {
                currentPageNumLocationEdit = pageNumber;
                if(pageNumLocationInput) pageNumLocationInput.value = currentPageNumLocationEdit;

                const pageWidth = page.getViewport({ scale: 1 }).width;
                currentScaleLocationEdit = locationEditPdfContainer.clientWidth / pageWidth;
                const viewport = page.getViewport({ scale: currentScaleLocationEdit });

                locationEditPdfContainer.style.height = `${viewport.height}px`;
                locationEditPdfCanvas.width = viewport.width;
                locationEditPdfCanvas.height = viewport.height;
                locationEditMarkerCanvas.width = viewport.width;
                locationEditMarkerCanvas.height = viewport.height;

                const renderContext = { canvasContext: locationEditPdfCanvas.getContext('2d'), viewport: viewport };
                page.render(renderContext).promise.then(() => {
                    updateLocationEditStatus('', false); // Clear status, show canvas
                    drawMarkerLocationEdit(); 
                }).catch(err => {
                    console.error(`Error rendering page ${pageNumber}:`, err);
                    updateLocationEditStatus('Error rendering PDF page: ' + err.message, false);
                });
            }).catch(err => {
                console.error(`Error getting page ${pageNumber}:`, err);
                updateLocationEditStatus('Error getting PDF page: ' + err.message, false);
            });
        }
        
        function loadPdfForLocationEditing() {
            const selectedOption = drawingSelectLocationEdit.options[drawingSelectLocationEdit.selectedIndex];
            const filePath = selectedOption ? selectedOption.dataset.filePath : null;
            console.log("Editable display - loadPdfForLocationEditing - filePath:", filePath, "currentMarkerDataLocation:", currentMarkerDataLocation);
            
            ctxLocationEdit.clearRect(0, 0, locationEditMarkerCanvas.width, locationEditMarkerCanvas.height); // Clear old marker

            if (!filePath) { 
                updateLocationEditStatus('Select a drawing to place a marker or view existing.', false);
                pdfDocLocationEdit = null;
                if(locationEditPdfCanvas) locationEditPdfCanvas.classList.add('hidden'); // Hide canvas
                if (locationEditPdfContainer) locationEditPdfContainer.classList.add('hidden');
                if(removeLocationButton) removeLocationButton.classList.add('hidden'); // Hide remove button if no drawing
                currentMarkerDataLocation = null; // Clear marker data if no drawing selected
                if(markerXLocationInput) markerXLocationInput.value = '';
                if(markerYLocationInput) markerYLocationInput.value = '';
                if(pageNumLocationInput) pageNumLocationInput.value = '1';
                return;
            }
            
            updateLocationEditStatus('Loading PDF...', true);
            if (locationEditPdfContainer) locationEditPdfContainer.classList.remove('hidden');
            const pdfUrl = `/static/${filePath}`;
            pdfjsLib.getDocument(pdfUrl).promise.then(loadedPdfDoc => {
                pdfDocLocationEdit = loadedPdfDoc;
                let initialPageToRender = 1;
                // If there's an existing marker for this drawing, use its page number
                const existingMarkerX = markerXLocationInput.value;
                const existingMarkerY = markerYLocationInput.value;
                const existingPageNum = pageNumLocationInput.value;
                const selectedDrawingId = drawingSelectLocationEdit.value;
                const initialMarkerDrawingId = "{{ marker.drawing_id if marker else '' }}";


                if (selectedDrawingId === initialMarkerDrawingId && existingMarkerX && existingMarkerY && existingPageNum) {
                     currentMarkerDataLocation = {
                        x: parseFloat(existingMarkerX),
                        y: parseFloat(existingMarkerY),
                        pageNum: parseInt(existingPageNum)
                    };
                    initialPageToRender = parseInt(existingPageNum) || 1;
                } else {
                    // New drawing selected, or no existing marker for this drawing
                    currentMarkerDataLocation = null; 
                    if(markerXLocationInput) markerXLocationInput.value = '';
                    if(markerYLocationInput) markerYLocationInput.value = '';
                    if(pageNumLocationInput) pageNumLocationInput.value = '1';
                }
                
                if(removeLocationButton) removeLocationButton.classList.toggle('hidden', !currentMarkerDataLocation);
                renderPageLocationEdit(initialPageToRender); 
            }).catch(err => {
                console.error(`Error loading PDF ${pdfUrl}:`, err);
                updateLocationEditStatus('Error loading PDF: ' + err.message, false);
                pdfDocLocationEdit = null;
                if (locationEditPdfContainer) locationEditPdfContainer.classList.add('hidden');
            });
        }

        function renderPageLocationEdit(pageNumber) {
            if (!pdfDocLocationEdit || !locationEditPdfContainer || !locationEditPdfCanvas) {
                updateLocationEditStatus('PDF document or canvas not ready.', false);
                if (locationEditPdfContainer) locationEditPdfContainer.classList.add('hidden');
                return;
            }
            console.log("Editable display - renderPageLocationEdit - pageNumber:", pageNumber, "currentScaleLocationEdit:", currentScaleLocationEdit);
            updateLocationEditStatus('Loading page ' + pageNumber + '...', true);
            if (locationEditPdfContainer) locationEditPdfContainer.classList.remove('hidden');
            pdfDocLocationEdit.getPage(pageNumber).then(page => {
                currentPageNumLocationEdit = pageNumber;
                if(pageNumLocationInput) pageNumLocationInput.value = currentPageNumLocationEdit;

                const pageWidth = page.getViewport({ scale: 1 }).width;
                currentScaleLocationEdit = locationEditPdfContainer.clientWidth / pageWidth;
                const viewport = page.getViewport({ scale: currentScaleLocationEdit });

                locationEditPdfContainer.style.height = `${viewport.height}px`;
                locationEditPdfCanvas.width = viewport.width;
                locationEditPdfCanvas.height = viewport.height;
                locationEditMarkerCanvas.width = viewport.width;
                locationEditMarkerCanvas.height = viewport.height;

                const renderContext = { canvasContext: locationEditPdfCanvas.getContext('2d'), viewport: viewport };
                page.render(renderContext).promise.then(() => {
                    updateLocationEditStatus('', false); // Clear status, show canvas
                    if (locationEditPdfContainer) locationEditPdfContainer.classList.remove('hidden');
                    drawMarkerLocationEdit();
                }).catch(err => {
                    console.error(`Error rendering page ${pageNumber}:`, err);
                    updateLocationEditStatus('Error rendering PDF page: ' + err.message, false);
                    if (locationEditPdfContainer) locationEditPdfContainer.classList.add('hidden');
                });
            }).catch(err => {
                console.error(`Error getting page ${pageNumber}:`, err);
                updateLocationEditStatus('Error getting PDF page: ' + err.message, false);
                if (locationEditPdfContainer) locationEditPdfContainer.classList.add('hidden');
            });
        }

        function drawMarkerLocationEdit() {
            if (!pdfDocLocationEdit || !ctxLocationEdit || !locationEditMarkerCanvas) return;
            ctxLocationEdit.clearRect(0, 0, locationEditMarkerCanvas.width, locationEditMarkerCanvas.height);
            if (currentMarkerDataLocation && currentMarkerDataLocation.pageNum === currentPageNumLocationEdit) {
                 pdfDocLocationEdit.getPage(currentPageNumLocationEdit).then(page => {
                    const viewport = page.getViewport({ scale: currentScaleLocationEdit });
                    const markerRadius = Math.max(5, Math.min(viewport.width, viewport.height) * 0.015);
                    const markerX = currentMarkerDataLocation.x * viewport.width;
                    const markerY = currentMarkerDataLocation.y * viewport.height;
                    console.log("Editable display - drawMarkerLocationEdit - currentMarkerDataLocation:", currentMarkerDataLocation, "Calculated X,Y:", markerX, markerY);
                    ctxLocationEdit.beginPath();
                    ctxLocationEdit.arc(markerX, markerY, markerRadius, 0, 2 * Math.PI, false);
                    ctxLocationEdit.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctxLocationEdit.fill();
                    ctxLocationEdit.lineWidth = Math.max(1, markerRadius * 0.2);
                    ctxLocationEdit.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    ctxLocationEdit.stroke();
                });
            }
        }

        locationEditMarkerCanvas.addEventListener('click', (event) => {
            if (!pdfDocLocationEdit) return;
            const rect = locationEditMarkerCanvas.getBoundingClientRect(); 
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const normalizedX = x / locationEditMarkerCanvas.clientWidth; 
            const normalizedY = y / locationEditMarkerCanvas.clientHeight;
            
            currentMarkerDataLocation = { 
                x: normalizedX, 
                y: normalizedY, 
                pageNum: currentPageNumLocationEdit 
            };
            
            if(markerXLocationInput) markerXLocationInput.value = normalizedX.toFixed(5);
            if(markerYLocationInput) markerYLocationInput.value = normalizedY.toFixed(5);
            if(pageNumLocationInput) pageNumLocationInput.value = currentPageNumLocationEdit; // Already set by renderPage
            
            drawMarkerLocationEdit();
            if(removeLocationButton) removeLocationButton.classList.remove('hidden'); // Show remove button once a marker is placed
        });
        
        drawingSelectLocationEdit.addEventListener('change', loadPdfForLocationEditing);
        
        // Initial load if a drawing is pre-selected (e.g., existing marker)
        if (drawingSelectLocationEdit.value) {
            if (locationEditPdfContainer) locationEditPdfContainer.classList.remove('hidden');
            loadPdfForLocationEditing();
        } else {
             updateLocationEditStatus('Select a drawing to place a marker.', false);
             if (locationEditPdfCanvas) locationEditPdfCanvas.classList.add('hidden');
             if (locationEditPdfContainer) locationEditPdfContainer.classList.add('hidden');
        }

        window.addEventListener('resize', () => { // Debounce this in a real app
             if (pdfDocLocationEdit && drawingSelectLocationEdit.value) {
                 renderPageLocationEdit(currentPageNumLocationEdit); 
             }
        });

        if(saveLocationButton) {
            saveLocationButton.addEventListener('click', function() {
                const selectedDrawingId = drawingSelectLocationEdit.value;
                const markerX = markerXLocationInput.value;
                const markerY = markerYLocationInput.value;
                const pageNum = pageNumLocationInput.value;

                if (locationUpdateMessage) locationUpdateMessage.textContent = 'Saving...';

                const payload = {
                    drawing_id: selectedDrawingId, // Will be empty if "None" is selected
                    x: selectedDrawingId ? markerX : null, // Send coords only if a drawing is selected
                    y: selectedDrawingId ? markerY : null,
                    page_num: selectedDrawingId ? pageNum : null
                };

                // If selectedDrawingId is present, but markerX or markerY is empty, it means a drawing is selected but no marker placed.
                // Backend should handle this (e.g. require x,y if drawing_id is present) or we add client validation.
                // For now, we allow sending if drawing is selected, assuming backend validates if x,y are needed.
                if (selectedDrawingId && (!markerX || !markerY)) {
                    if(confirm('No marker is placed on the selected drawing. Do you want to save just the drawing association without a specific point, or clear the location? \nClick OK to save without a point (if supported) or Cancel to keep editing.')){
                        // Allow backend to decide if this is valid, or it might clear if x,y are null
                    } else {
                         if (locationUpdateMessage) locationUpdateMessage.textContent = '';
                        return;
                    }
                }


                fetch(`/defect/${defectId}/update_location`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken 
                    },
                    body: JSON.stringify(payload)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(errData => { throw new Error(errData.error || `HTTP error ${response.status}`); });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        if (locationUpdateMessage) {
                            locationUpdateMessage.textContent = 'Saved!';
                            setTimeout(() => { if(locationUpdateMessage) locationUpdateMessage.textContent = ''; }, 2000);
                        }
                        if (data.marker_removed) {
                            currentMarkerDataLocation = null;
                            if(markerXLocationInput) markerXLocationInput.value = '';
                            if(markerYLocationInput) markerYLocationInput.value = '';
                            if(pageNumLocationInput) pageNumLocationInput.value = '1';
                            drawMarkerLocationEdit(); // Clear marker from canvas
                            if(removeLocationButton) removeLocationButton.classList.add('hidden');
                        } else if (data.marker) {
                            // Update hidden fields and currentMarkerDataLocation with potentially new ID or confirmed data
                            if(markerXLocationInput) markerXLocationInput.value = data.marker.x;
                            if(markerYLocationInput) markerYLocationInput.value = data.marker.y;
                            if(pageNumLocationInput) pageNumLocationInput.value = data.marker.page_num;
                            currentMarkerDataLocation = { x: data.marker.x, y: data.marker.y, pageNum: data.marker.page_num };
                            // No need to redraw if data hasn't changed, but good for consistency if backend adjusts values
                            drawMarkerLocationEdit(); 
                            if(removeLocationButton) removeLocationButton.classList.remove('hidden');
                        }
                         // Update the simple defect.location text if it's displayed elsewhere (not directly handled here)
                    } else {
                        if (locationUpdateMessage) locationUpdateMessage.textContent = 'Error!';
                        alert('Error: ' + (data.error || 'Unknown error updating location.'));
                    }
                })
                .catch(error => {
                    console.error('Error saving location:', error);
                    if (locationUpdateMessage) locationUpdateMessage.textContent = 'Error!';
                    alert('An error occurred: ' + error.message);
                });
            });
        }

        if(removeLocationButton) {
            removeLocationButton.addEventListener('click', function() {
                if (confirm('Are you sure you want to remove the marker location?')) {
                    drawingSelectLocationEdit.value = ''; // Select "None"
                    if(markerXLocationInput) markerXLocationInput.value = '';
                    if(markerYLocationInput) markerYLocationInput.value = '';
                    if(pageNumLocationInput) pageNumLocationInput.value = '1';
                    currentMarkerDataLocation = null;
                    drawMarkerLocationEdit(); // Clear marker from canvas
                    
                    // Trigger save logic which will now send empty drawing_id
                    if(saveLocationButton) saveLocationButton.click(); 
                    
                    this.classList.add('hidden'); // Hide remove button
                }
            });
        }
    } // This closes the if (drawingSelectLocationEdit && locationEditPdfContainer && locationEditMarkerCanvas) block.
}); // This closes document.addEventListener('DOMContentLoaded', function ()
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function () {
        const defectPageProjectDropdownButton = document.getElementById('defect-page-project-dropdown-button');
        const defectPageProjectDropdownList = document.getElementById('defect-page-project-dropdown-list');

        if (defectPageProjectDropdownButton && defectPageProjectDropdownList) {
            defectPageProjectDropdownButton.addEventListener('click', function (event) {
                defectPageProjectDropdownList.classList.toggle('hidden');
                event.stopPropagation();
            });

            window.addEventListener('click', function (event) {
                if (defectPageProjectDropdownButton && defectPageProjectDropdownList && !defectPageProjectDropdownList.classList.contains('hidden') && !defectPageProjectDropdownButton.contains(event.target) && !defectPageProjectDropdownList.contains(event.target)) {
                    defectPageProjectDropdownList.classList.add('hidden');
                }
            });
        }
});
</script>
{% endblock %}